#pragma OPENCL EXTENSION cl_khr_fp16 : enable
#pragma OPENCL EXTENSION CL_VIV_asm : enable
#pragma OPENCL EXTENSION cl_viv_bitfield_extension : enable


__kernel void gpuDepthwiseConv_FP32(
    image2d_array_t input,
    image2d_t weight,
    image2d_t bias,
    int channel_multiplier,
    int kernelX,
    int kernelY,
    int strideX,
    int strideY,
    int padX,
    int padY,
    image2d_array_t output)
{
    int x = get_global_id(0);
    int y = get_global_id(1);
    int z = get_global_id(2);
    int inputWeight = get_image_width(input);
    int inputHeight = get_image_height(input);
    int inputDepth = get_image_array_size(input);
    int4 coord_out = (int4)(x, y, z, 0);
    int inz = convert_int(convert_short(z)/convert_short(channel_multiplier));
    int inyStart = y * strideY - padY;
    int inyEnd = inyStart + kernelY;
    int inxStart = x * strideX - padX;
    int inxEnd = inxStart + kernelX;
    int4 coord_in = (int4)(inxStart, inyStart, inz, 0);
    int2 coord_wei;
    float sum = 0;
    int   kernelXLeft = 0;
    float4 dst = {0.0};
    float4 pixel = {0.0};
    float4 weightValue = {0.0};

    inyEnd = min(inyEnd, inputHeight);
    inxEnd = min(inxEnd, inputWeight);
    kernelXLeft = kernelX - (inxEnd - inxStart);
    sum = read_imagef(bias, (int2)(z, 0)).x;
    coord_wei = (int2)(0, z);

    if (inz < inputDepth)
    {
        for (coord_in.y = inyStart; coord_in.y < inyEnd; coord_in.y++)
        {
            for (coord_in.x = inxStart; coord_in.x < inxEnd; coord_in.x++)
            {
                pixel = read_imagef(input, coord_in);
                weightValue = read_imagef(weight, coord_wei);
                sum += (pixel.x * weightValue.x);
                coord_wei.x += 1;
            }
            coord_wei.x += kernelXLeft;
        }
    }

    dst.x = sum;
    write_imagef(output, coord_out, dst);
}

#define F32_3x3_PROCESS() \
    pixel  = read_imagef(input, coord_in); \
    if (inxStart < 0) \
    {   \
        switch(inxStart) \
        { \
            case -1: \
                pixel.yz  = pixel.xy; \
                pixel.x   = 0.0;   \
            break; \
            case -2: \
                pixel.z    = pixel.x; \
                pixel.xy   = 0.0; \
            break; \
            default: \
                pixel     = 0.0; \
            break; \
        } \
    } \
    else if (inxEndLeft > 0) \
    { \
        switch(inxEndLeft) \
        { \
            case 1: \
                pixel.z = 0.0; \
            break; \
            case 2: \
                pixel.yz = 0.0; \
            break; \
            default: \
                pixel = 0.0; \
            break; \
        } \
    } \
    weightValue  = read_imagef(weight, coord_wei); \
    sum  += dot(pixel, weightValue);

__kernel void gpuDepthwiseConv_3x3_FP32(
    image2d_array_t input,
    image2d_t weight,
    image2d_t bias,
    int channel_multiplier,
    int kernelX,
    int kernelY,
    int strideX,
    int strideY,
    int padX,
    int padY,
    image2d_array_t output)
{
    int x = get_global_id(0);
    int y = get_global_id(1);
    int z = get_global_id(2);
    int inputWidth = get_image_width(input);
    int inputHeight = get_image_height(input);
    int inputDepth = get_image_array_size(input);
    int4 coord_out = (int4)(x, y, z, 0);
    int inz = convert_int(convert_short(z)/convert_short(channel_multiplier));
    int inyStart = y * strideY - padY;
    int inxStart = x * strideX - padX;
    int inxEndLeft = inxStart + kernelX - inputWidth;
    int4 coord_in = (int4)(inxStart, inyStart, inz, 0);
    int2 coord_wei;
    float sum = 0;
    float4 dst = {0.0};
    float4 pixel = {0.0};
    float4 weightValue = {0.0};

    sum = read_imagef(bias, (int2)(z, 0)).x;
    coord_in.x = coord_in.x < 0 ? 0 : coord_in.x;
    coord_wei = (int2)(0, z);
    F32_3x3_PROCESS()
    coord_in.y++;
    coord_wei.x += kernelX;
    F32_3x3_PROCESS()
    coord_in.y++;
    coord_wei.x += kernelX;
    F32_3x3_PROCESS()

    dst.x = sum;
    write_imagef(output, coord_out, dst);
}

__kernel void gpuDepthwiseConv_3x3_FP16(
    image2d_array_t input,
    image2d_t weight,
    image2d_t bias,
    int channel_multiplier,
    int kernelX,
    int kernelY,
    int strideX,
    int strideY,
    int padX,
    int padY,
    image2d_array_t output)
{
    int x = get_global_id(0);
    int y = get_global_id(1);
    int z = get_global_id(2);
    int inputWidth = get_image_width(input);
    int inputHeight = get_image_height(input);
    int inputDepth = get_image_array_size(input);
    int4 coord_out = (int4)(x, y, z, 0);
    int inz = convert_int(convert_short(z)/convert_short(channel_multiplier));
    int inyStart = y * strideY - padY;
    int inxStart = x * strideX - padX;
    int inxEndLeft = inxStart + kernelX - inputWidth;
    int4 coord_in = (int4)(inxStart, inyStart, inz, 0);
    int2 coord_wei;
    float sum = 0;
    float4 dst = {0.0};
    float4 pixel = {0.0};
    float4 weightValue = {0.0};

    sum = read_imagef(bias, (int2)(z, 0)).x;
    coord_in.x = coord_in.x < 0 ? 0 : coord_in.x;
    coord_wei = (int2)(0, z);
    F32_3x3_PROCESS()
    coord_in.y++;
    coord_wei.x += kernelX;
    F32_3x3_PROCESS()
    coord_in.y++;
    coord_wei.x += kernelX;
    F32_3x3_PROCESS()

    dst.x = sum;
    write_imagef(output, coord_out, dst);
}


#define U8_3x3_PROCESS() \
    tmp0  = read_imageui(input, coord_in); \
    if (inxStart < 0) \
    {   \
        switch(inxStart) \
        { \
            case -1: \
                tmp0.yzw = tmp0.xyz; \
                tmp0.x   = zpIn_int;   \
            break; \
            case -2: \
                tmp0.zw   = tmp0.xy; \
                tmp0.xy   = zpIn_int; \
            break; \
            default: \
                tmp0     = zpIn_int; \
            break; \
        } \
    } \
    else if (inxEndLeft > 0) \
    { \
        switch(inxEndLeft) \
        { \
            case 1: \
                tmp0.z = zpIn_int; \
            break; \
            case 2: \
                tmp0.yz = zpIn_int; \
            break; \
            default: \
                tmp0 = zpIn_int; \
            break; \
        } \
    } \
    tmp1  = read_imageui(weight, coord_wei); \
    pixel = convert_float4(tmp0); \
    weightValue = convert_float4(tmp1) -  zpWeight; \
    pixel.w  = 0; \
    sum  += dot(pixel, weightValue);

__kernel void gpuDepthwiseConv_3x3_c1_Quant8(
    image2d_array_t input,
    image2d_t weight,
    image2d_t bias,
    int channel_multiplier,
    int kernelX,
    int kernelY,
    int strideX,
    int strideY,
    int padX,
    int padY,
    float scaleOut,
    float zpIn,
    float zpWeight,
    float zpOut,
    int    zpIn_int,
    image2d_array_t output)
{
    int x = get_global_id(0);
    int y = get_global_id(1);
    int z = get_global_id(2);
    int inputWidth  = get_image_width(input);
    int inputHeight = get_image_height(input);
    int inputDepth = get_image_array_size(input);
    int4 coord_out = (int4)(x, y, z, 0);
    int inz = z;
    int inyStart = y * strideY - padY;
    int inxStart = x * strideX - padX;
    int inxEndLeft = inxStart + kernelX - inputWidth;
    int4 coord_in = (int4)(inxStart, inyStart, inz, 0);
    int2 coord_wei = (int2)(0, z);
    float sum = 0;
    uint4 dst = {0}, tmp0 = {0}, tmp1 = {0};
    int4 biasData;
    float4 pixel = {0.0}, weightValue = {0.0};
    biasData = convert_int(read_imagei(bias, (int2)(z, 0)));
    sum = biasData.x;
    coord_in.x = coord_in.x < 0 ? 0 : coord_in.x;
    U8_3x3_PROCESS()
    coord_in.y++;
    coord_wei.x += kernelX;
    U8_3x3_PROCESS()
    coord_in.y++;
    coord_wei.x += kernelX;
    U8_3x3_PROCESS()
    dst.x = floor(sum * scaleOut + zpOut);
    write_imageui(output, coord_out, dst);
}

__kernel void gpuDepthwiseConv_3x3_Quant8(
    image2d_array_t input,
    image2d_t weight,
    image2d_t bias,
    int channel_multiplier,
    int kernelX,
    int kernelY,
    int strideX,
    int strideY,
    int padX,
    int padY,
    float scaleOut,
    float zpIn,
    float zpWeight,
    float zpOut,
    int    zpIn_int,
    image2d_array_t output)
{
    int x = get_global_id(0);
    int y = get_global_id(1);
    int z = get_global_id(2);
    int inputWidth  = get_image_width(input);
    int inputHeight = get_image_height(input);
    int inputDepth = get_image_array_size(input);
    int4 coord_out = (int4)(x, y, z, 0);
    int inz = convert_int(convert_short(z)/convert_short(channel_multiplier));
    int inyStart = y * strideY - padY;
    int inxStart = x * strideX - padX;
    int inxEndLeft = inxStart + kernelX - inputWidth;
    int4 coord_in = (int4)(inxStart, inyStart, inz, 0);
    int2 coord_wei = (int2)(0, z);
    float sum = 0;
    uint4 dst = {0}, tmp0 = {0}, tmp1 = {0};
    int4 biasData;
    float4 pixel = {0.0}, weightValue = {0.0};
    biasData = convert_int(read_imagei(bias, (int2)(z, 0)));
    sum = biasData.x;
    coord_in.x = coord_in.x < 0 ? 0 : coord_in.x;
    U8_3x3_PROCESS()
    coord_in.y++;
    coord_wei.x += kernelX;
    U8_3x3_PROCESS()
    coord_in.y++;
    coord_wei.x += kernelX;
    U8_3x3_PROCESS()
    dst.x = floor(sum * scaleOut + zpOut);
    write_imageui(output, coord_out, dst);
}

#define U8_3x3_X2_PROCESS() \
    tmp0  = read_imageui(input, coord_in); \
    if (inxStart < 0) \
    {   \
        switch(inxStart) \
        { \
            case -1: \
                tmp0.yzw = tmp0.xyz; \
                tmp0.x   = zpIn_int;   \
            break; \
            case -2: \
                tmp0.zw   = tmp0.xy; \
                tmp0.xy   = zpIn_int; \
            break; \
            default: \
                tmp0     = zpIn_int; \
            break; \
        } \
    } \
    else if (inxEndLeft > 0) \
    { \
        switch(inxEndLeft) \
        { \
            case 1: \
                tmp0.w = zpIn_int; \
            break; \
            case 2: \
                tmp0.zw = zpIn_int; \
            break; \
            case 3: \
                tmp0.yzw = zpIn_int; \
            break; \
            default: \
                tmp0 = zpIn_int; \
            break; \
        } \
    } \
    tmp1  = read_imageui(weight, coord_wei); \
    pixel = convert_float4(tmp0); \
    weightValue = convert_float4(tmp1) -  zpWeight; \
    pixel2.xyz = pixel.yzw; \
    pixel.w  = 0; \
    sum.x  += dot(pixel, weightValue); \
    sum.y  += dot(pixel2, weightValue);

__kernel void gpuDepthwiseConv_3x3_c1_s1_Quant8_x2(
    image2d_array_t input,
    image2d_t weight,
    image2d_t bias,
    int channel_multiplier,
    int kernelX,
    int kernelY,
    int strideX,
    int strideY,
    int padX,
    int padY,
    float scaleOut,
    float zpIn,
    float zpWeight,
    float zpOut,
    int    zpIn_int,
    image2d_array_t output)
{
    int x = get_global_id(0);
    int y = get_global_id(1);
    int z = get_global_id(2);
    int inputWidth  = get_image_width(input);
    int inputHeight = get_image_height(input);
    int inputDepth = get_image_array_size(input);
    int4 coord_out = (int4)(x, y, z, 0);
    int inz = z;
    int inyStart = y * strideY - padY;
    int inxStart = x * strideX - padX;
    int inxEndLeft = inxStart + 4 - inputWidth;
    int4 coord_in = (int4)(inxStart, inyStart, inz, 0);
    int2 coord_wei = (int2)(0, z);
    float4 sum = 0;
    uint4 dst = {0}, tmp0 = {0}, tmp1 = {0};
    float biasData;
    float4 pixel = {0.0}, weightValue = {0.0}, pixel2 = {0.0};
    biasData = convert_float(read_imagei(bias, (int2)(z, 0)));
    sum = biasData;
    coord_in.x = coord_in.x < 0 ? 0 : coord_in.x;

    U8_3x3_X2_PROCESS()
    coord_in.y++;
    coord_wei.x += kernelX;
    U8_3x3_X2_PROCESS()
    coord_in.y++;
    coord_wei.x += kernelX;
    U8_3x3_X2_PROCESS()
    dst = convert_uint4(sum * scaleOut + zpOut);
    write_imageui(output, coord_out, dst);
}
#define U8_3x3_X2_S2_PROCESS() \
    tmp0  = read_imageui(input, coord_in); \
    tmp2  = read_imageui(input, coord_in2); \
    if (inxStart < 0) \
    {   \
        switch(inxStart) \
        { \
            case -1: \
                tmp0.yzw = tmp0.xyz; \
                tmp0.x   = zpIn_int;   \
            break; \
            case -2: \
                tmp0.zw   = tmp0.xy; \
                tmp0.xy   = zpIn_int; \
            break; \
            default: \
                tmp0     = zpIn_int; \
            break; \
        } \
    } \
    if (inxEndLeft > 0) \
    { \
        switch(inxEndLeft) \
        { \
            case 1: \
                tmp2.w = zpIn_int; \
            break; \
            case 2: \
                tmp2.zw = zpIn_int; \
            break; \
            case 3: \
                tmp2.yzw = zpIn_int; \
            break; \
            default: \
                tmp2 = zpIn_int; \
            break; \
        } \
    } \
    tmp1  = read_imageui(weight, coord_wei); \
    pixel = convert_float4(tmp0); \
    weightValue = convert_float4(tmp1) -  zpWeight; \
    pixel2 = convert_float4(tmp2); \
    weightValue.w  = 0; \
    sum.x  += dot(pixel, weightValue); \
    sum.y  += dot(pixel2, weightValue);
__kernel void gpuDepthwiseConv_3x3_c1_s2_Quant8_x2(
    image2d_array_t input,
    image2d_t weight,
    image2d_t bias,
    int channel_multiplier,
    int kernelX,
    int kernelY,
    int strideX,
    int strideY,
    int padX,
    int padY,
    float scaleOut,
    float zpIn,
    float zpWeight,
    float zpOut,
    int    zpIn_int,
    image2d_array_t output)
{
    int x = get_global_id(0);
    int y = get_global_id(1);
    int z = get_global_id(2);
    int inputWidth  = get_image_width(input);
    int inputHeight = get_image_height(input);
    int inputDepth = get_image_array_size(input);
    int4 coord_out = (int4)(x, y, z, 0);
    int inz = z;
    int inyStart = y * strideY - padY;
    int inxStart = x * strideX - padX;
    int inxEndLeft = inxStart + 6 - inputWidth;
    int4 coord_in = (int4)(inxStart, inyStart, inz, 0);
    int4 coord_in2 = (int4)(inxStart + 2, inyStart, inz, 0);
    int2 coord_wei = (int2)(0, z);
    float4 sum = 0;
    uint4 dst = {0}, tmp0 = {0}, tmp1 = {0}, tmp2 = {0};
    float biasData;
    float4 pixel = {0.0}, weightValue = {0.0}, pixel2 = {0.0};
    biasData = convert_float(read_imagei(bias, (int2)(z, 0)));
    sum = biasData;
    coord_in.x = coord_in.x < 0 ? 0 : coord_in.x;

    U8_3x3_X2_S2_PROCESS()
    coord_in.y++;
    coord_in2.y++;
    coord_wei.x += kernelX;
    U8_3x3_X2_S2_PROCESS()
    coord_in.y++;
    coord_in2.y++;
    coord_wei.x += kernelX;
    U8_3x3_X2_S2_PROCESS()
    dst = convert_uint4(sum * scaleOut + zpOut);
    write_imageui(output, coord_out, dst);
}

#define U8_3x3_X4_S2_PROCESS() \
    tmp0  = read_imageui(input, coord_in); \
    tmp2  = read_imageui(input, coord_in2); \
    tmp3  = read_imageui(input, coord_in3); \
    tmp4  = read_imageui(input, coord_in4); \
    if (inxStart < 0) \
    {   \
        switch(inxStart) \
        { \
            case -1: \
                tmp0.yzw = tmp0.xyz; \
                tmp0.x   = zpIn_int;   \
            break; \
            default: \
                tmp0     = zpIn_int; \
            break; \
        } \
    } \
    if (inxEndLeft > 0) \
    { \
        switch(inxEndLeft) \
        { \
            case 1: \
                tmp4.w = zpIn_int; \
            break; \
            case 2: \
                tmp4.zw = zpIn_int; \
            break; \
            default: \
                tmp4 = zpIn_int; \
            break; \
        } \
    } \
    tmp1  = read_imageui(weight, coord_wei); \
    pixel = convert_float4(tmp0); \
    weightValue = convert_float4(tmp1) -  zpWeight; \
    pixel2 = convert_float4(tmp2); \
    weightValue.w  = 0; \
    sum.x  += dot(pixel, weightValue); \
    sum.y  += dot(pixel2, weightValue); \
    pixel3 = convert_float4(tmp3); \
    pixel4 = convert_float4(tmp4); \
    sum.z  += dot(pixel3, weightValue); \
    sum.w  += dot(pixel4, weightValue);

__kernel void gpuDepthwiseConv_3x3_c1_s2_Quant8_x4(
    image2d_array_t input,
    image2d_t weight,
    image2d_t bias,
    int channel_multiplier,
    int kernelX,
    int kernelY,
    int strideX,
    int strideY,
    int padX,
    int padY,
    float scaleOut,
    float zpIn,
    float zpWeight,
    float zpOut,
    int    zpIn_int,
    image2d_array_t output)
{
    int x = get_global_id(0);
    int y = get_global_id(1);
    int z = get_global_id(2);
    int inputWidth  = get_image_width(input);
    int inputHeight = get_image_height(input);
    int inputDepth = get_image_array_size(input);
    int4 coord_out = (int4)(x, y, z, 0);
    int inz = z;
    int inyStart = y * strideY - padY;
    int inxStart = x * strideX - padX;
    int inxEndLeft = inxStart + 10 - inputWidth;
    int4 coord_in = (int4)(inxStart, inyStart, inz, 0);
    int4 coord_in2 = (int4)(inxStart + 2, inyStart, inz, 0);
    int4 coord_in3 = (int4)(inxStart + 4, inyStart, inz, 0);
    int4 coord_in4 = (int4)(inxStart + 6, inyStart, inz, 0);
    int2 coord_wei = (int2)(0, z);
    float4 sum = 0;
    uint4 dst = {0}, tmp0 = {0}, tmp1 = {0}, tmp2 = {0}, tmp3 = {0}, tmp4 = {0};
    float biasData;
    float4 pixel = {0.0}, weightValue = {0.0}, pixel2 = {0.0}, pixel3 = {0.0}, pixel4 = {0.0};
    biasData = convert_float(read_imagei(bias, (int2)(z, 0)));
    sum = biasData;
    coord_in.x = coord_in.x < 0 ? 0 : coord_in.x;

    U8_3x3_X4_S2_PROCESS()
    coord_in.y++;
    coord_in2.y++;
    coord_in3.y++;
    coord_in4.y++;
    coord_wei.x += kernelX;
    U8_3x3_X4_S2_PROCESS()
    coord_in.y++;
    coord_in2.y++;
    coord_in3.y++;
    coord_in4.y++;
    coord_wei.x += kernelX;
    U8_3x3_X4_S2_PROCESS()
    dst = convert_uint4(sum * scaleOut + zpOut);
    write_imageui(output, coord_out, dst);
}

#define U8_3x3_X4_S2_NOPAD_PROCESS() \
    tmp0  = read_imageui(input, coord_in); \
    tmp2  = read_imageui(input, coord_in2); \
    tmp3  = read_imageui(input, coord_in3); \
    tmp4  = read_imageui(input, coord_in4); \
    tmp1  = read_imageui(weight, coord_wei); \
    pixel = convert_float4(tmp0); \
    weightValue = convert_float4(tmp1) -  zpWeight; \
    pixel2 = convert_float4(tmp2); \
    weightValue.w  = 0; \
    sum.x  += dot(pixel, weightValue); \
    sum.y  += dot(pixel2, weightValue); \
    pixel3 = convert_float4(tmp3); \
    pixel4 = convert_float4(tmp4); \
    sum.z  += dot(pixel3, weightValue); \
    sum.w  += dot(pixel4, weightValue);

__kernel void gpuDepthwiseConv_3x3_c1_s2_NoPad_Quant8_x4(
    image2d_array_t input,
    image2d_t weight,
    image2d_t bias,
    int channel_multiplier,
    int kernelX,
    int kernelY,
    int strideX,
    int strideY,
    int padX,
    int padY,
    float scaleOut,
    float zpIn,
    float zpWeight,
    float zpOut,
    int    zpIn_int,
    image2d_array_t output)
{
    int x = get_global_id(0);
    int y = get_global_id(1);
    int z = get_global_id(2);
    int inputWidth  = get_image_width(input);
    int inputHeight = get_image_height(input);
    int inputDepth = get_image_array_size(input);
    int4 coord_out = (int4)(x, y, z, 0);
    int inz = z;
    int inyStart = y * strideY - padY;
    int inxStart = x * strideX - padX;
    int4 coord_in = (int4)(inxStart, inyStart, inz, 0);
    int4 coord_in2 = (int4)(inxStart + 2, inyStart, inz, 0);
    int4 coord_in3 = (int4)(inxStart + 4, inyStart, inz, 0);
    int4 coord_in4 = (int4)(inxStart + 6, inyStart, inz, 0);
    int2 coord_wei = (int2)(0, z);
    float4 sum = 0;
    uint4 dst = {0}, tmp0 = {0}, tmp1 = {0}, tmp2 = {0}, tmp3 = {0}, tmp4 = {0};
    float biasData;
    float4 pixel = {0.0}, weightValue = {0.0}, pixel2 = {0.0}, pixel3 = {0.0}, pixel4 = {0.0};
    biasData = convert_float(read_imagei(bias, (int2)(z, 0)));
    sum = biasData;
    coord_in.x = coord_in.x < 0 ? 0 : coord_in.x;

    U8_3x3_X4_S2_NOPAD_PROCESS()
    coord_in.y++;
    coord_in2.y++;
    coord_in3.y++;
    coord_in4.y++;
    coord_wei.x += kernelX;
    U8_3x3_X4_S2_NOPAD_PROCESS()
    coord_in.y++;
    coord_in2.y++;
    coord_in3.y++;
    coord_in4.y++;
    coord_wei.x += kernelX;
    U8_3x3_X4_S2_NOPAD_PROCESS()
    dst = convert_uint4(sum * scaleOut + zpOut);
    write_imageui(output, coord_out, dst);
}

#define U8_3x3_X4_PROCESS() \
    tmp0  = read_imageui(input, coord_in); \
    tmp2  = read_imageui(input, coord_in2); \
    if (inxStart < 0) \
    {   \
        switch(inxStart) \
        { \
            case -1: \
                tmp0.yzw = tmp0.xyz; \
                tmp0.x   = zpIn_int;   \
            break; \
            default: \
                tmp0     = zpIn_int; \
            break; \
        } \
    } \
    if (inxEndLeft > 0) \
    { \
        switch(inxEndLeft) \
        { \
            case 1: \
                tmp2.w = zpIn_int; \
            break; \
            case 2: \
                tmp2.zw = zpIn_int; \
            break; \
            default: \
                tmp2 = zpIn_int; \
            break; \
        } \
    } \
    tmp1  = read_imageui(weight, coord_wei); \
    pixel = convert_float4(tmp0); \
    weightValue = convert_float4(tmp1) -  zpWeight; \
    pixel2.xyz = pixel.yzw; \
    weightValue.w  = 0; \
    sum.x  += dot(pixel, weightValue); \
    sum.y  += dot(pixel2, weightValue); \
    pixel3 = convert_float4(tmp2); \
    pixel4.xyz = pixel3.yzw; \
    sum.z  += dot(pixel3, weightValue); \
    sum.w  += dot(pixel4, weightValue);

__kernel void gpuDepthwiseConv_3x3_c1_s1_Quant8_x4(
    image2d_array_t input,
    image2d_t weight,
    image2d_t bias,
    int channel_multiplier,
    int kernelX,
    int kernelY,
    int strideX,
    int strideY,
    int padX,
    int padY,
    float scaleOut,
    float zpIn,
    float zpWeight,
    float zpOut,
    int    zpIn_int,
    image2d_array_t output)
{
    int x = get_global_id(0);
    int y = get_global_id(1);
    int z = get_global_id(2);
    int inputWidth  = get_image_width(input);
    int inputHeight = get_image_height(input);
    int inputDepth = get_image_array_size(input);
    int4 coord_out = (int4)(x, y, z, 0);
    int inz = z;
    int inyStart = y * strideY - padY;
    int inxStart = x * strideX - padX;
    int inxEndLeft = inxStart  + 6  - inputWidth;
    int4 coord_in = (int4)(inxStart, inyStart, inz, 0);
    int4 coord_in2 = (int4)(inxStart + 2, inyStart, inz, 0);
    int2 coord_wei = (int2)(0, z);
    float4 sum = 0;
    uint4 dst = {0}, tmp0 = {0}, tmp1 = {0}, tmp2 = {0};
    float biasData;
    float4 pixel = {0.0}, weightValue = {0.0}, pixel2 = {0.0}, pixel3 = {0.0}, pixel4 = {0.0};
    biasData = convert_float(read_imagei(bias, (int2)(z, 0)));
    sum = biasData;
    coord_in.x = coord_in.x < 0 ? 0 : coord_in.x;

    U8_3x3_X4_PROCESS()
    coord_in.y++;
    coord_in2.y++;
    coord_wei.x += kernelX;
    U8_3x3_X4_PROCESS()
    coord_in.y++;
    coord_in2.y++;
    coord_wei.x += kernelX;
    U8_3x3_X4_PROCESS()
    dst = convert_uint4(sum * scaleOut + zpOut);
    write_imageui(output, coord_out, dst);
}


#define U8_3x3_X4_NOPAD_PROCESS() \
    tmp0  = read_imageui(input, coord_in); \
    tmp2  = read_imageui(input, coord_in1); \
    tmp3  = read_imageui(input, coord_in2); \
    tmp1  = read_imageui(weight, coord_wei); \
    pixel = convert_float4(tmp0); \
    pixel3 = convert_float4(tmp3); \
    pixel2 = convert_float4(tmp2); \
    weightValue = convert_float4(tmp1) -  zpWeight; \
    sum  +=  pixel  * weightValue.x; \
    sum  +=  pixel2 * weightValue.y; \
    sum  +=  pixel3 * weightValue.z;


__kernel void gpuDepthwiseConv_3x3_c1_s1_NoPad_Quant8_x4(
    image2d_array_t input,
    image2d_t weight,
    image2d_t bias,
    int channel_multiplier,
    int kernelX,
    int kernelY,
    int strideX,
    int strideY,
    int padX,
    int padY,
    float scaleOut,
    float zpIn,
    float zpWeight,
    float zpOut,
    int    zpIn_int,
    image2d_array_t output)
{
    int x = get_global_id(0);
    int y = get_global_id(1);
    int z = get_global_id(2);
    int inputWidth  = get_image_width(input);
    int inputHeight = get_image_height(input);
    int inputDepth = get_image_array_size(input);
    int4 coord_out = (int4)(x, y, z, 0);
    int inz = z;
    int inyStart = y;
    int inxStart = x;
    int4 coord_in = (int4)(inxStart, inyStart, inz, 0);
    int4 coord_in1 = (int4)(inxStart + 1, inyStart, inz, 0);
    int4 coord_in2 = (int4)(inxStart + 2, inyStart, inz, 0);
    int2 coord_wei = (int2)(0, z);
    float4 sum = 0;
    uint4 dst = {0}, tmp0 = {0}, tmp1 = {0}, tmp2 = {0}, tmp3 = {0};
    float biasData;
    float4 pixel = {0.0}, weightValue = {0.0}, pixel2 = {0.0}, pixel3 = {0.0};
    biasData = convert_float(read_imagei(bias, (int2)(z, 0)));
    sum = biasData;
    U8_3x3_X4_NOPAD_PROCESS()
    coord_in.y++;
    coord_in1.y++;
    coord_in2.y++;
    coord_wei.x += kernelX;
    U8_3x3_X4_NOPAD_PROCESS()
    coord_in.y++;
    coord_in1.y++;
    coord_in2.y++;
    coord_wei.x += kernelX;
    U8_3x3_X4_NOPAD_PROCESS()
    dst = convert_uint4(sum * scaleOut + zpOut);
    write_imageui(output, coord_out, dst);
}


#define U8_3x3_X4_NOPAD_2D_PROCESS() \
    tmp0  = read_imageui(input, coord_in.xy); \
    tmp2  = read_imageui(input, coord_in.zy); \
    tmp3  = read_imageui(input, coord_in.wy); \
    tmp1  = read_imageui(weight, coord_wei); \
    pixel = convert_float4(tmp0); \
    pixel3 = convert_float4(tmp3); \
    pixel2 = convert_float4(tmp2); \
    weightValue = convert_float4(tmp1) -  zpWeight; \
    sum  +=  pixel  * weightValue.x; \
    sum  +=  pixel2 * weightValue.y; \
    sum  +=  pixel3 * weightValue.z;

__kernel void gpuDepthwiseConv_3x3_c1_s1_NoPad_Quant8_x4_2D(
    image2d_t input,
    image2d_t weight,
    image2d_t bias,
    int outputHeight,
    int heigt_diff,
    float scaleOut,
    float zpIn,
    float zpWeight,
    float zpOut,
    int    zpIn_int,
    image2d_t output)
{
    int x = get_global_id(0);
    int y = get_global_id(1);
    int depth = convert_int(convert_short(y)/convert_short(outputHeight));
    int inyStart = y + depth * heigt_diff;
    int2 coord_out = (int2)(x, y);
    int inxStart = x;
    int4 coord_in = (int4)(inxStart, inyStart, inxStart + 1, inxStart + 2);
    int2 coord_wei = (int2)(0, depth);
    float4 sum = 0;
    uint4 dst = {0}, tmp0 = {0}, tmp1 = {0}, tmp2 = {0}, tmp3 = {0};
    float biasData;
    float4 pixel = {0.0}, weightValue = {0.0}, pixel2 = {0.0}, pixel3 = {0.0};
    biasData = convert_float(read_imagei(bias, (int2)(depth, 0)));
    sum = biasData;
    U8_3x3_X4_NOPAD_2D_PROCESS()
    coord_in.y++;
    coord_wei.x += 3;
    U8_3x3_X4_NOPAD_2D_PROCESS()
    coord_in.y++;
    coord_wei.x += 3;
    U8_3x3_X4_NOPAD_2D_PROCESS()
    dst = convert_uint4(sum * scaleOut + zpOut);
    write_imageui(output, coord_out, dst);
}


#define U8_3x3_X4_NOPAD_Q32toQ8_2D_PROCESS() \
    tmp4  = read_imageui(input, coord_in); \
    tmp0  = viv_bitfieldExtract(tmp4.xxxx, cfg, bits); \
    tmp2  = viv_bitfieldExtract(tmp4.xxxy, cfg1, bits); \
    tmp3  = viv_bitfieldExtract(tmp4.xxyy, cfg2, bits); \
    tmp1  = read_imageui(weight, coord_wei); \
    pixel = convert_float4(tmp0); \
    pixel2 = convert_float4(tmp2); \
    pixel3 = convert_float4(tmp3); \
    weightValue = convert_float4(tmp1) -  zpWeight; \
    sum  +=  pixel  * weightValue.x; \
    sum  +=  pixel2 * weightValue.y; \
    sum  +=  pixel3 * weightValue.z;

__kernel void gpuDepthwiseConv_3x3_c1_s1_NoPad_Q32toQ8_x4_2D(
    image2d_t input,
    image2d_t weight,
    image2d_t bias,
    int outputHeight,
    int heigt_diff,
    float scaleOut,
    float zpIn,
    float zpWeight,
    float zpOut,
    int    zpIn_int,
    image2d_t output)
{
    int x = get_global_id(0);
    int y = get_global_id(1);
    int depth = convert_int(convert_short(y)/convert_short(outputHeight));
    int inyStart = y + depth * heigt_diff;
    int2 coord_out = (int2)(x, y);
    int inxStart = x >> 2;
    int2 coord_in = (int2)(inxStart, inyStart);
    int2 coord_wei = (int2)(0, depth);
    float4 sum = 0;
    uint4 dst = {0}, tmp0 = {0}, tmp1 = {0}, tmp2 = {0}, tmp3 = {0}, tmp4 = {0};
    float biasData;
    float4 pixel = {0.0}, weightValue = {0.0}, pixel2 = {0.0}, pixel3 = {0.0};
    uint4 bits = (uint4)(8, 8, 8, 8);
    uint4 cfg = (uint4)(0, 8, 16, 24);
    uint4 cfg1 = (uint4)(8, 16, 24, 0);
    uint4 cfg2 = (uint4)(16, 24, 0, 8);

    biasData = convert_float(read_imagei(bias, (int2)(depth, 0)));
    sum = biasData;
    U8_3x3_X4_NOPAD_Q32toQ8_2D_PROCESS()
    coord_in.y++;
    coord_wei.x += 3;
    U8_3x3_X4_NOPAD_Q32toQ8_2D_PROCESS()
    coord_in.y++;
    coord_wei.x += 3;
    U8_3x3_X4_NOPAD_Q32toQ8_2D_PROCESS()
    dst = convert_uint4(sum * scaleOut + zpOut);
    write_imageui(output, coord_out, dst);
}

#define U8_3x3_X4_S2_NOPAD_Q32toQ8_2D_PROCESS() \
    tmp4  = read_imageui(input, coord_in); \
    tmp0  = viv_bitfieldExtract(tmp4.xxyy, cfg, bits); \
    tmp2  = viv_bitfieldExtract(tmp4.xxyy, cfg1, bits); \
    tmp3  = viv_bitfieldExtract(tmp4.xyyz, cfg2, bits); \
    tmp1  = read_imageui(weight, coord_wei); \
    pixel = convert_float4(tmp0); \
    pixel2 = convert_float4(tmp2); \
    pixel3 = convert_float4(tmp3); \
    weightValue = convert_float4(tmp1) -  zpWeight; \
    sum  +=  pixel  * weightValue.x; \
    sum  +=  pixel2 * weightValue.y; \
    sum  +=  pixel3 * weightValue.z;

__kernel void gpuDepthwiseConv_3x3_c1_s2_NoPad_Q32toQ8_x4_2D(
    image2d_t input,
    image2d_t weight,
    image2d_t bias,
    int outputHeight,
    int heigt_diff,
    float scaleOut,
    float zpIn,
    float zpWeight,
    float zpOut,
    int    zpIn_int,
    image2d_t output)
{
    int x = get_global_id(0);
    int y = get_global_id(1);
    int depth = convert_int(convert_short(y)/convert_short(outputHeight));
    int inyStart = y * 2 + depth * (heigt_diff - outputHeight);
    int2 coord_out = (int2)(x, y);
    int inxStart = x >> 1;
    int2 coord_in = (int2)(inxStart, inyStart);
    int2 coord_wei = (int2)(0, depth);
    float4 sum = 0;
    uint4 dst = {0}, tmp0 = {0}, tmp1 = {0}, tmp2 = {0}, tmp3 = {0}, tmp4 = {0};
    float biasData;
    float4 pixel = {0.0}, weightValue = {0.0}, pixel2 = {0.0}, pixel3 = {0.0};
    uint4 bits = (uint4)(8, 8, 8, 8);
    uint4 cfg = (uint4)(0, 16, 0, 16);
    uint4 cfg1 = (uint4)(8, 24, 8, 24);
    uint4 cfg2 = (uint4)(16, 0, 16, 0);

    biasData = convert_float(read_imagei(bias, (int2)(depth, 0)));
    sum = biasData;
    U8_3x3_X4_S2_NOPAD_Q32toQ8_2D_PROCESS()
    coord_in.y++;
    coord_wei.x += 3;
    U8_3x3_X4_S2_NOPAD_Q32toQ8_2D_PROCESS()
    coord_in.y++;
    coord_wei.x += 3;
    U8_3x3_X4_S2_NOPAD_Q32toQ8_2D_PROCESS()
    dst = convert_uint4(sum * scaleOut + zpOut);
    write_imageui(output, coord_out, dst);
}


#define U8_3x3_X8_NOPAD_Q32_2D_PROCESS() \
    tmp4  = read_imageui(input, coord_in); \
    tmp0  = viv_bitfieldExtract(tmp4.xxxx, cfg, bits); \
    tmp2  = viv_bitfieldExtract(tmp4.xxxy, cfg1, bits); \
    tmp3  = viv_bitfieldExtract(tmp4.xxyy, cfg2, bits); \
    tmp1  = read_imageui(weight, coord_wei); \
    weightValue = convert_float4(tmp1) -  zpWeight; \
    pixel = convert_float4(tmp0); \
    pixel2 = convert_float4(tmp2); \
    pixel3 = convert_float4(tmp3); \
    sum[0]  +=  pixel  * weightValue.x; \
    sum[0]  +=  pixel2 * weightValue.y; \
    sum[0]  +=  pixel3 * weightValue.z; \
    tmp0  = viv_bitfieldExtract(tmp4.yyyy, cfg, bits); \
    tmp2  = viv_bitfieldExtract(tmp4.yyyz, cfg1, bits); \
    tmp3  = viv_bitfieldExtract(tmp4.yyzz, cfg2, bits); \
    pixel = convert_float4(tmp0); \
    pixel2 = convert_float4(tmp2); \
    pixel3 = convert_float4(tmp3); \
    sum[1]  +=  pixel  * weightValue.x; \
    sum[1]  +=  pixel2 * weightValue.y; \
    sum[1]  +=  pixel3 * weightValue.z;

__kernel void gpuDepthwiseConv_3x3_c1_s1_NoPad_Q32_x8_2D(
    image2d_t input,
    image2d_t weight,
    image2d_t bias,
    int outputHeight,
    int heigt_diff,
    float scaleOut,
    float zpIn,
    float zpWeight,
    float zpOut,
    int    zpIn_int,
    image2d_t output)
{
    int x = get_global_id(0);
    int y = get_global_id(1);
    int depth = convert_int(convert_short(y)/convert_short(outputHeight));
    int inyStart = y + depth * heigt_diff;
    int4 coord_out = (int4)(x, y, x + 4, 0);
    int inxStart = x >> 2;
    int2 coord_in = (int2)(inxStart, inyStart);
    int2 coord_wei = (int2)(0, depth);
    float4 sum[2];
    uint4 dst[2], tmp0 = {0}, tmp1 = {0}, tmp2 = {0}, tmp3 = {0}, tmp4 = {0};
    float biasData;
    float4 pixel = {0.0}, weightValue = {0.0}, pixel2 = {0.0}, pixel3 = {0.0};
    uint4 bits = (uint4)(8, 8, 8, 8);
    uint4 cfg = (uint4)(0, 8, 16, 24);
    uint4 cfg1 = (uint4)(8, 16, 24, 0);
    uint4 cfg2 = (uint4)(16, 24, 0, 8);

    biasData = convert_float(read_imagei(bias, (int2)(depth, 0)));
    sum[0] = biasData;
    sum[1] = biasData;
    U8_3x3_X8_NOPAD_Q32_2D_PROCESS()
    coord_in.y++;
    coord_wei.x += 3;
    U8_3x3_X8_NOPAD_Q32_2D_PROCESS()
    coord_in.y++;
    coord_wei.x += 3;
    U8_3x3_X8_NOPAD_Q32_2D_PROCESS()
    dst[0] = convert_uint4(sum[0] * scaleOut + zpOut);
    dst[1] = convert_uint4(sum[1] * scaleOut + zpOut);
    write_imageui(output, coord_out.xy, dst[0]);
    write_imageui(output, coord_out.zy, dst[1]);
}


#define U8_3x3_X8_S2_NOPAD_Q32_2D_PROCESS() \
    tmp4  = read_imageui(input, coord_in.xy); \
    tmp5  = read_imageui(input, coord_in.zy); \
    tmp0  = viv_bitfieldExtract(tmp4.xxyy, cfg, bits); \
    tmp2  = viv_bitfieldExtract(tmp4.xxyy, cfg1, bits); \
    tmp3  = viv_bitfieldExtract(tmp4.xyyz, cfg2, bits); \
    tmp1  = read_imageui(weight, coord_wei); \
    weightValue = convert_float4(tmp1) -  zpWeight; \
    pixel = convert_float4(tmp0); \
    pixel2 = convert_float4(tmp2); \
    pixel3 = convert_float4(tmp3); \
    sum[0]  +=  pixel  * weightValue.x; \
    sum[0]  +=  pixel2 * weightValue.y; \
    sum[0]  +=  pixel3 * weightValue.z; \
    tmp0  = viv_bitfieldExtract(tmp5.xxyy, cfg, bits); \
    tmp2  = viv_bitfieldExtract(tmp5.xxyy, cfg1, bits); \
    tmp3  = viv_bitfieldExtract(tmp5.xyyz, cfg2, bits); \
    pixel = convert_float4(tmp0); \
    pixel2 = convert_float4(tmp2); \
    pixel3 = convert_float4(tmp3); \
    sum[1]  +=  pixel  * weightValue.x; \
    sum[1]  +=  pixel2 * weightValue.y; \
    sum[1]  +=  pixel3 * weightValue.z;

__kernel void gpuDepthwiseConv_3x3_c1_s2_NoPad_Q32_x8_2D(
    image2d_t input,
    image2d_t weight,
    image2d_t bias,
    int outputHeight,
    int heigt_diff,
    float scaleOut,
    float zpIn,
    float zpWeight,
    float zpOut,
    int    zpIn_int,
    image2d_t output)
{
    int x = get_global_id(0);
    int y = get_global_id(1);
    int depth = convert_int(convert_short(y)/convert_short(outputHeight));
    int inyStart = y * 2 + depth * (heigt_diff - outputHeight);
    int4 coord_out = (int4)(x, y, x + 4, 0);
    int inxStart = x >> 1;
    int4 coord_in = (int4)(inxStart, inyStart, inxStart + 2, 0);
    int2 coord_wei = (int2)(0, depth);
    float4 sum[2];
    uint4 dst[2], tmp0 = {0}, tmp1 = {0}, tmp2 = {0}, tmp3 = {0}, tmp4 = {0}, tmp5 = {0};
    float biasData;
    float4 pixel = {0.0}, weightValue = {0.0}, pixel2 = {0.0}, pixel3 = {0.0};
    uint4 bits = (uint4)(8, 8, 8, 8);
    uint4 cfg = (uint4)(0, 16, 0, 16);
    uint4 cfg1 = (uint4)(8, 24, 8, 24);
    uint4 cfg2 = (uint4)(16, 0, 16, 0);

    biasData = convert_float(read_imagei(bias, (int2)(depth, 0)));
    sum[0] = biasData;
    sum[1] = biasData;
    U8_3x3_X8_S2_NOPAD_Q32_2D_PROCESS()
    coord_in.y++;
    coord_wei.x += 3;
    U8_3x3_X8_S2_NOPAD_Q32_2D_PROCESS()
    coord_in.y++;
    coord_wei.x += 3;
    U8_3x3_X8_S2_NOPAD_Q32_2D_PROCESS()
    dst[0] = convert_uint4(sum[0] * scaleOut + zpOut);
    dst[1] = convert_uint4(sum[1] * scaleOut + zpOut);
    write_imageui(output, coord_out.xy, dst[0]);
    write_imageui(output, coord_out.zy, dst[1]);
}


#define U8_3x3_W14_NOPAD_Q32toQ8_2D_PROCESS() \
    tmp4  = read_imageui(input, coord_in.xy); \
    tmp0  = viv_bitfieldExtract(tmp4.xxxx, cfg, bits); \
    tmp2  = viv_bitfieldExtract(tmp4.xxxy, cfg1, bits); \
    tmp3  = viv_bitfieldExtract(tmp4.xxyy, cfg2, bits); \
    tmp1  = read_imageui(weight, coord_wei); \
    weightValue = convert_float4(tmp1) -  zpWeight; \
    pixel = convert_float4(tmp0); \
    pixel2 = convert_float4(tmp2); \
    pixel3 = convert_float4(tmp3); \
    sum[0]  +=  pixel  * weightValue.x; \
    sum[0]  +=  pixel2 * weightValue.y; \
    sum[0]  +=  pixel3 * weightValue.z; \
    tmp0  = viv_bitfieldExtract(tmp4.yyyy, cfg, bits); \
    tmp2  = viv_bitfieldExtract(tmp4.yyyz, cfg1, bits); \
    tmp3  = viv_bitfieldExtract(tmp4.yyzz, cfg2, bits); \
    pixel = convert_float4(tmp0); \
    pixel2 = convert_float4(tmp2); \
    pixel3 = convert_float4(tmp3); \
    sum[1]  +=  pixel  * weightValue.x; \
    sum[1]  +=  pixel2 * weightValue.y; \
    sum[1]  +=  pixel3 * weightValue.z; \
    tmp0  = viv_bitfieldExtract(tmp4.zzzz, cfg, bits); \
    tmp2  = viv_bitfieldExtract(tmp4.zzzw, cfg1, bits); \
    tmp3  = viv_bitfieldExtract(tmp4.zzww, cfg2, bits); \
    pixel = convert_float4(tmp0); \
    pixel2 = convert_float4(tmp2); \
    pixel3 = convert_float4(tmp3); \
    sum[2]  +=  pixel  * weightValue.x; \
    sum[2]  +=  pixel2 * weightValue.y; \
    sum[2]  +=  pixel3 * weightValue.z; \
    tmp0  = viv_bitfieldExtract(tmp4.wwww, cfg, bits); \
    tmp2  = viv_bitfieldExtract(tmp4.wwwx, cfg1, bits); \
    tmp3  = viv_bitfieldExtract(tmp4.wwxx, cfg2, bits); \
    pixel = convert_float4(tmp0); \
    pixel2 = convert_float4(tmp2); \
    pixel3 = convert_float4(tmp3); \
    sum[3]  +=  pixel  * weightValue.x; \
    sum[3]  +=  pixel2 * weightValue.y; \
    sum[3]  +=  pixel3 * weightValue.z;

__kernel void gpuDepthwiseConv_3x3_c1_s1_NoPad_Q32toQ8_w14_2D(
    image2d_t input,
    image2d_t weight,
    image2d_t bias,
    int outputHeight,
    int heigt_diff,
    float scaleOut,
    float zpIn,
    float zpWeight,
    float zpOut,
    int    zpIn_int,
    image2d_t output)
{
    int x = get_global_id(0);
    int y = get_global_id(1);
    int depth = convert_int(convert_short(y)/convert_short(outputHeight));
    int inyStart = y + depth * heigt_diff;
    int4 coord_out = (int4)(x, y, x + 2, x + 4);
    int inxStart = x;
    int4 coord_in = (int4)(inxStart, inyStart, x + 6, y);
    int2 coord_wei = (int2)(0, depth);
    float4 sum[4];
    uint4 dst[4], tmp0 = {0}, tmp1 = {0}, tmp2 = {0}, tmp3 = {0}, tmp4 = {0};
    float biasData;
    float4 pixel = {0.0}, weightValue = {0.0}, pixel2 = {0.0}, pixel3 = {0.0};
    uint4 bits = (uint4)(8, 8, 8, 8);
    uint4 cfg = (uint4)(0, 8, 16, 24);
    uint4 cfg1 = (uint4)(8, 16, 24, 0);
    uint4 cfg2 = (uint4)(16, 24, 0, 8);

    biasData = convert_float(read_imagei(bias, (int2)(depth, 0)));
    sum[0] = biasData;
    sum[1] = biasData;
    sum[2] = biasData;
    sum[3] = biasData;
    U8_3x3_W14_NOPAD_Q32toQ8_2D_PROCESS()
    coord_in.y++;
    coord_wei.x += 3;
    U8_3x3_W14_NOPAD_Q32toQ8_2D_PROCESS()
    coord_in.y++;
    coord_wei.x += 3;
    U8_3x3_W14_NOPAD_Q32toQ8_2D_PROCESS()
    dst[0] = convert_uint4(sum[0] * scaleOut + zpOut);
    dst[1] = convert_uint4(sum[1] * scaleOut + zpOut);
    dst[2] = convert_uint4(sum[2] * scaleOut + zpOut);
    dst[3] = convert_uint4(sum[3] * scaleOut + zpOut);

    write_imageui(output, coord_out.xy, dst[0].xyxy);
    write_imageui(output, coord_out.zy, dst[0].zwzw);
    write_imageui(output, coord_out.wy, dst[1].xyxy);
    write_imageui(output, coord_in.zw, dst[1].zwzw);
    coord_out.xzw += 8;
    write_imageui(output, coord_out.xy, dst[2].xyxy);
    write_imageui(output, coord_out.zy, dst[2].zwzw);
    write_imageui(output, coord_out.wy, dst[3].xyxy);
}


#define U8_3x3_W14_S2_NOPAD_Q32toQ8_2D_PROCESS() \
    tmp4  = read_imageui(input, coord_in.xy); \
    tmp5  = read_imageui(input, coord_in.zy); \
    tmp6  = read_imageui(input, coord_in.wy); \
    tmp0  = viv_bitfieldExtract(tmp4.xxyy, cfg, bits); \
    tmp2  = viv_bitfieldExtract(tmp4.xxyy, cfg1, bits); \
    tmp3  = viv_bitfieldExtract(tmp4.xyyz, cfg2, bits); \
    tmp1  = read_imageui(weight, coord_wei); \
    weightValue = convert_float4(tmp1) -  zpWeight; \
    pixel = convert_float4(tmp0); \
    pixel2 = convert_float4(tmp2); \
    pixel3 = convert_float4(tmp3); \
    sum[0]  +=  pixel  * weightValue.x; \
    sum[0]  +=  pixel2 * weightValue.y; \
    sum[0]  +=  pixel3 * weightValue.z; \
    tmp0  = viv_bitfieldExtract(tmp5.xxyy, cfg, bits); \
    tmp2  = viv_bitfieldExtract(tmp5.xxyy, cfg1, bits); \
    tmp3  = viv_bitfieldExtract(tmp5.xyyz, cfg2, bits); \
    pixel = convert_float4(tmp0); \
    pixel2 = convert_float4(tmp2); \
    pixel3 = convert_float4(tmp3); \
    sum[1]  +=  pixel  * weightValue.x; \
    sum[1]  +=  pixel2 * weightValue.y; \
    sum[1]  +=  pixel3 * weightValue.z; \
    tmp0  = viv_bitfieldExtract(tmp6.xxyy, cfg, bits); \
    tmp2  = viv_bitfieldExtract(tmp6.xxyy, cfg1, bits); \
    tmp3  = viv_bitfieldExtract(tmp6.xyyz, cfg2, bits); \
    pixel = convert_float4(tmp0); \
    pixel2 = convert_float4(tmp2); \
    pixel3 = convert_float4(tmp3); \
    sum[2]  +=  pixel  * weightValue.x; \
    sum[2]  +=  pixel2 * weightValue.y; \
    sum[2]  +=  pixel3 * weightValue.z; \
    tmp0  = viv_bitfieldExtract(tmp6.zzww, cfg, bits); \
    tmp2  = viv_bitfieldExtract(tmp6.zzww, cfg1, bits); \
    tmp3  = viv_bitfieldExtract(tmp6.zwwx, cfg2, bits); \
    pixel = convert_float4(tmp0); \
    pixel2 = convert_float4(tmp2); \
    pixel3 = convert_float4(tmp3); \
    sum[3]  +=  pixel  * weightValue.x; \
    sum[3]  +=  pixel2 * weightValue.y; \
    sum[3]  +=  pixel3 * weightValue.z;

__kernel void gpuDepthwiseConv_3x3_c1_s2_NoPad_Q32toQ8_w14_2D(
    image2d_t input,
    image2d_t weight,
    image2d_t bias,
    int outputHeight,
    int heigt_diff,
    float scaleOut,
    float zpIn,
    float zpWeight,
    float zpOut,
    int    zpIn_int,
    image2d_t output)
{
    int x = get_global_id(0);
    int y = get_global_id(1);
    int depth = convert_int(convert_short(y)/convert_short(outputHeight));
    int inyStart = y * 2 + depth * (heigt_diff - outputHeight);
    int4 coord_out = (int4)(x, y, x + 2, x + 4);
    int inxStart = x;
    int4 coord_in = (int4)(inxStart, inyStart, inxStart + 2, inxStart + 4);
    int2 coord_wei = (int2)(0, depth);
    float4 sum[4];
    uint4 dst[4], tmp0 = {0}, tmp1 = {0}, tmp2 = {0}, tmp3 = {0}, tmp4 = {0}, tmp5 = {0}, tmp6 = {0};
    float biasData;
    float4 pixel = {0.0}, weightValue = {0.0}, pixel2 = {0.0}, pixel3 = {0.0};
    uint4 bits = (uint4)(8, 8, 8, 8);
    uint4 cfg = (uint4)(0, 16, 0, 16);
    uint4 cfg1 = (uint4)(8, 24, 8, 24);
    uint4 cfg2 = (uint4)(16, 0, 16, 0);

    biasData = convert_float(read_imagei(bias, (int2)(depth, 0)));
    sum[0] = biasData;
    sum[1] = biasData;
    sum[2] = biasData;
    sum[3] = biasData;
    U8_3x3_W14_S2_NOPAD_Q32toQ8_2D_PROCESS()
    coord_in.y++;
    coord_wei.x += 3;
    U8_3x3_W14_S2_NOPAD_Q32toQ8_2D_PROCESS()
    coord_in.y++;
    coord_wei.x += 3;
    U8_3x3_W14_S2_NOPAD_Q32toQ8_2D_PROCESS()
    dst[0] = convert_uint4(sum[0] * scaleOut + zpOut);
    dst[1] = convert_uint4(sum[1] * scaleOut + zpOut);
    dst[2] = convert_uint4(sum[2] * scaleOut + zpOut);
    dst[3] = convert_uint4(sum[3] * scaleOut + zpOut);

    write_imageui(output, coord_out.xy, dst[0].xyxy);
    write_imageui(output, coord_out.zy, dst[0].zwzw);
    write_imageui(output, coord_out.wy, dst[1].xyxy);
    coord_out.xzw += 6;
    write_imageui(output, coord_out.xy, dst[1].zwzw);
    write_imageui(output, coord_out.zy, dst[2].xyxy);
    write_imageui(output, coord_out.wy, dst[2].zwzw);
    coord_out.xzw += 6;
    write_imageui(output, coord_out.xy, dst[3].xyxy);
}


#define U8_3x3_W7_NOPAD_Q32toQ8_2D_PROCESS() \
    tmp4  = read_imageui(input, coord_in.xy); \
    tmp0  = viv_bitfieldExtract(tmp4.xxxx, cfg, bits); \
    tmp2  = viv_bitfieldExtract(tmp4.xxxy, cfg1, bits); \
    tmp3  = viv_bitfieldExtract(tmp4.xxyy, cfg2, bits); \
    tmp1  = read_imageui(weight, coord_wei); \
    weightValue = convert_float4(tmp1) -  zpWeight; \
    pixel = convert_float4(tmp0); \
    pixel2 = convert_float4(tmp2); \
    pixel3 = convert_float4(tmp3); \
    sum[0]  +=  pixel  * weightValue.x; \
    sum[0]  +=  pixel2 * weightValue.y; \
    sum[0]  +=  pixel3 * weightValue.z; \
    tmp0  = viv_bitfieldExtract(tmp4.yyyy, cfg, bits); \
    tmp2  = viv_bitfieldExtract(tmp4.yyyz, cfg1, bits); \
    tmp3  = viv_bitfieldExtract(tmp4.yyzz, cfg2, bits); \
    pixel = convert_float4(tmp0); \
    pixel2 = convert_float4(tmp2); \
    pixel3 = convert_float4(tmp3); \
    sum[1]  +=  pixel  * weightValue.x; \
    sum[1]  +=  pixel2 * weightValue.y; \
    sum[1]  +=  pixel3 * weightValue.z;

__kernel void gpuDepthwiseConv_3x3_c1_s1_NoPad_Q32toQ8_w7_2D(
    image2d_t input,
    image2d_t weight,
    image2d_t bias,
    int outputHeight,
    int heigt_diff,
    float scaleOut,
    float zpIn,
    float zpWeight,
    float zpOut,
    int    zpIn_int,
    image2d_t output)
{
    int x = get_global_id(0);
    int y = get_global_id(1);
    int depth = convert_int(convert_short(y)/convert_short(outputHeight));
    int inyStart = y + depth * heigt_diff;
    int4 coord_out = (int4)(x, y, x + 1, x + 2);
    int inxStart = x;
    int4 coord_in = (int4)(inxStart, inyStart, x + 3, y);
    int2 coord_wei = (int2)(0, depth);
    float4 sum[2];
    uint4 dst[2], tmp0 = {0}, tmp1 = {0}, tmp2 = {0}, tmp3 = {0}, tmp4 = {0};
    float biasData;
    float4 pixel = {0.0}, weightValue = {0.0}, pixel2 = {0.0}, pixel3 = {0.0};
    uint4 bits = (uint4)(8, 8, 8, 8);
    uint4 cfg = (uint4)(0, 8, 16, 24);
    uint4 cfg1 = (uint4)(8, 16, 24, 0);
    uint4 cfg2 = (uint4)(16, 24, 0, 8);

    biasData = convert_float(read_imagei(bias, (int2)(depth, 0)));
    sum[0] = biasData;
    sum[1] = biasData;
    U8_3x3_W7_NOPAD_Q32toQ8_2D_PROCESS()
    coord_in.y++;
    coord_wei.x += 3;
    U8_3x3_W7_NOPAD_Q32toQ8_2D_PROCESS()
    coord_in.y++;
    coord_wei.x += 3;
    U8_3x3_W7_NOPAD_Q32toQ8_2D_PROCESS()
    dst[0] = convert_uint4(sum[0] * scaleOut + zpOut);
    dst[1] = convert_uint4(sum[1] * scaleOut + zpOut);

    write_imageui(output, coord_out.xy, dst[0].xxxx);
    write_imageui(output, coord_out.zy, dst[0].yyyy);
    write_imageui(output, coord_out.wy, dst[0].zzzz);
    write_imageui(output, coord_in.zw,  dst[0].wwww);
    coord_out.xzw += 4;
    write_imageui(output, coord_out.xy, dst[1].xxxx);
    write_imageui(output, coord_out.zy, dst[1].yyyy);
    write_imageui(output, coord_out.wy, dst[1].zzzz);
}


#define U8_3x3_W7_S2_NOPAD_Q32toQ8_2D_PROCESS() \
    tmp4  = read_imageui(input, coord_in.xy); \
    tmp0  = viv_bitfieldExtract(tmp4.xxyy, cfg, bits); \
    tmp2  = viv_bitfieldExtract(tmp4.xxyy, cfg1, bits); \
    tmp3  = viv_bitfieldExtract(tmp4.xyyz, cfg2, bits); \
    tmp1  = read_imageui(weight, coord_wei); \
    weightValue = convert_float4(tmp1) -  zpWeight; \
    pixel = convert_float4(tmp0); \
    pixel2 = convert_float4(tmp2); \
    pixel3 = convert_float4(tmp3); \
    sum[0]  +=  pixel  * weightValue.x; \
    sum[0]  +=  pixel2 * weightValue.y; \
    sum[0]  +=  pixel3 * weightValue.z; \
    tmp0  = viv_bitfieldExtract(tmp4.zzww, cfg, bits); \
    tmp2  = viv_bitfieldExtract(tmp4.zzww, cfg1, bits); \
    tmp3  = viv_bitfieldExtract(tmp4.zwwx, cfg2, bits); \
    pixel = convert_float4(tmp0); \
    pixel2 = convert_float4(tmp2); \
    pixel3 = convert_float4(tmp3); \
    sum[1]  +=  pixel  * weightValue.x; \
    sum[1]  +=  pixel2 * weightValue.y; \
    sum[1]  +=  pixel3 * weightValue.z;

__kernel void gpuDepthwiseConv_3x3_c1_s2_NoPad_Q32toQ8_w7_2D(
    image2d_t input,
    image2d_t weight,
    image2d_t bias,
    int outputHeight,
    int heigt_diff,
    float scaleOut,
    float zpIn,
    float zpWeight,
    float zpOut,
    int    zpIn_int,
    image2d_t output)
{
    int x = get_global_id(0);
    int y = get_global_id(1);
    int depth = convert_int(convert_short(y)/convert_short(outputHeight));
    int inyStart = y * 2 + depth * (heigt_diff - outputHeight);
    int4 coord_out = (int4)(x, y, x + 1, x + 2);
    int inxStart = x;
    int4 coord_in = (int4)(inxStart, inyStart, x + 3, y);
    int2 coord_wei = (int2)(0, depth);
    float4 sum[2];
    uint4 dst[2], tmp0 = {0}, tmp1 = {0}, tmp2 = {0}, tmp3 = {0}, tmp4 = {0};
    float biasData;
    float4 pixel = {0.0}, weightValue = {0.0}, pixel2 = {0.0}, pixel3 = {0.0};
    uint4 bits = (uint4)(8, 8, 8, 8);
    uint4 cfg = (uint4)(0, 16, 0, 16);
    uint4 cfg1 = (uint4)(8, 24, 8, 24);
    uint4 cfg2 = (uint4)(16, 0, 16, 0);

    biasData = convert_float(read_imagei(bias, (int2)(depth, 0)));
    sum[0] = biasData;
    sum[1] = biasData;
    U8_3x3_W7_S2_NOPAD_Q32toQ8_2D_PROCESS()
    coord_in.y++;
    coord_wei.x += 3;
    U8_3x3_W7_S2_NOPAD_Q32toQ8_2D_PROCESS()
    coord_in.y++;
    coord_wei.x += 3;
    U8_3x3_W7_S2_NOPAD_Q32toQ8_2D_PROCESS()
    dst[0] = convert_uint4(sum[0] * scaleOut + zpOut);
    dst[1] = convert_uint4(sum[1] * scaleOut + zpOut);

    write_imageui(output, coord_out.xy, dst[0].xxxx);
    write_imageui(output, coord_out.zy, dst[0].yyyy);
    write_imageui(output, coord_out.wy, dst[0].zzzz);
    write_imageui(output, coord_in.zw,  dst[0].wwww);
    coord_out.xzw += 4;
    write_imageui(output, coord_out.xy, dst[1].xxxx);
    write_imageui(output, coord_out.zy, dst[1].yyyy);
    write_imageui(output, coord_out.wy, dst[1].zzzz);
}

#define U8_3x3_X16_NOPAD_Q32_2D_PROCESS() \
    tmp4  = read_imageui(input, coord_in.xy); \
    tmp5  = read_imageui(input, coord_in.zy); \
    tmp0  = viv_bitfieldExtract(tmp4.xxxx, cfg, bits); \
    tmp2  = viv_bitfieldExtract(tmp4.xxxy, cfg1, bits); \
    tmp3  = viv_bitfieldExtract(tmp4.xxyy, cfg2, bits); \
    tmp1  = read_imageui(weight, coord_wei); \
    weightValue = convert_float4(tmp1) -  zpWeight; \
    pixel = convert_float4(tmp0); \
    pixel2 = convert_float4(tmp2); \
    pixel3 = convert_float4(tmp3); \
    sum[0]  +=  pixel  * weightValue.x; \
    sum[0]  +=  pixel2 * weightValue.y; \
    sum[0]  +=  pixel3 * weightValue.z; \
    tmp0  = viv_bitfieldExtract(tmp4.yyyy, cfg, bits); \
    tmp2  = viv_bitfieldExtract(tmp4.yyyz, cfg1, bits); \
    tmp3  = viv_bitfieldExtract(tmp4.yyzz, cfg2, bits); \
    pixel = convert_float4(tmp0); \
    pixel2 = convert_float4(tmp2); \
    pixel3 = convert_float4(tmp3); \
    sum[1]  +=  pixel  * weightValue.x; \
    sum[1]  +=  pixel2 * weightValue.y; \
    sum[1]  +=  pixel3 * weightValue.z; \
    tmp0  = viv_bitfieldExtract(tmp4.zzzz, cfg, bits); \
    tmp2  = viv_bitfieldExtract(tmp4.zzzw, cfg1, bits); \
    tmp3  = viv_bitfieldExtract(tmp4.zzww, cfg2, bits); \
    pixel = convert_float4(tmp0); \
    pixel2 = convert_float4(tmp2); \
    pixel3 = convert_float4(tmp3); \
    sum[2]  +=  pixel  * weightValue.x; \
    sum[2]  +=  pixel2 * weightValue.y; \
    sum[2]  +=  pixel3 * weightValue.z; \
    tmp0  = viv_bitfieldExtract(tmp5.xxxx, cfg, bits); \
    tmp2  = viv_bitfieldExtract(tmp5.xxxy, cfg1, bits); \
    tmp3  = viv_bitfieldExtract(tmp5.xxyy, cfg2, bits); \
    pixel = convert_float4(tmp0); \
    pixel2 = convert_float4(tmp2); \
    pixel3 = convert_float4(tmp3); \
    sum[3]  +=  pixel  * weightValue.x; \
    sum[3]  +=  pixel2 * weightValue.y; \
    sum[3]  +=  pixel3 * weightValue.z;

__kernel void gpuDepthwiseConv_3x3_c1_s1_NoPad_Q32_x16_2D(
    image2d_t input,
    image2d_t weight,
    image2d_t bias,
    int outputHeight,
    int heigt_diff,
    float scaleOut,
    float zpIn,
    float zpWeight,
    float zpOut,
    int    zpIn_int,
    image2d_t output)
{
    int x = get_global_id(0);
    int y = get_global_id(1);
    int depth = convert_int(convert_short(y)/convert_short(outputHeight));
    int inyStart = y + depth * heigt_diff;
    int4 coord_out = (int4)(x, y, x + 4, x + 8);
    int inxStart = x >> 2;
    int4 coord_in = (int4)(inxStart, inyStart, inxStart + 3, 0);
    int2 coord_wei = (int2)(0, depth);
    float4 sum[4];
    uint4  dst[4];
    uint4  tmp0 = {0}, tmp1 = {0}, tmp2 = {0}, tmp3 = {0}, tmp4 = {0}, tmp5 = {0};
    float biasData;
    float4 pixel = {0.0}, weightValue = {0.0}, pixel2 = {0.0}, pixel3 = {0.0};
    uint4 bits = (uint4)(8, 8, 8, 8);
    uint4 cfg = (uint4)(0, 8, 16, 24);
    uint4 cfg1 = (uint4)(8, 16, 24, 0);
    uint4 cfg2 = (uint4)(16, 24, 0, 8);

    biasData = convert_float(read_imagei(bias, (int2)(depth, 0)));
    sum[0] = biasData;
    sum[1] = biasData;
    sum[2] = biasData;
    sum[3] = biasData;
    U8_3x3_X16_NOPAD_Q32_2D_PROCESS()
    coord_in.y++;
    coord_wei.x += 3;
    U8_3x3_X16_NOPAD_Q32_2D_PROCESS()
    coord_in.y++;
    coord_wei.x += 3;
    U8_3x3_X16_NOPAD_Q32_2D_PROCESS()
    dst[0] = convert_uint4(sum[0] * scaleOut + zpOut);
    dst[1] = convert_uint4(sum[1] * scaleOut + zpOut);
    dst[2] = convert_uint4(sum[2] * scaleOut + zpOut);
    dst[3] = convert_uint4(sum[3] * scaleOut + zpOut);
    write_imageui(output, coord_out.xy, dst[0]);
    write_imageui(output, coord_out.zy, dst[1]);
    write_imageui(output, coord_out.wy, dst[2]);
    coord_out.w += 4;
    write_imageui(output, coord_out.wy, dst[3]);
}

#define U8_3x3_X2_NOPAD_2D_PROCESS() \
    tmp0  = read_imageui(input, coord_in); \
    tmp1  = read_imageui(weight, coord_wei); \
    pixel = convert_float4(tmp0); \
    pixel2.xyz = pixel.yzw; \
    weightValue = convert_float4(tmp1) -  zpWeight; \
    weightValue.w = 0.0f; \
    sum.x  += dot(pixel, weightValue); \
    sum.y  += dot(pixel2, weightValue);

__kernel void gpuDepthwiseConv_3x3_c1_s1_NoPad_Quant8_x2_2D(
    image2d_t input,
    image2d_t weight,
    image2d_t bias,
    int outputHeight,
    int heigt_diff,
    float scaleOut,
    float zpIn,
    float zpWeight,
    float zpOut,
    int    zpIn_int,
    image2d_t output)
{
    int x = get_global_id(0);
    int y = get_global_id(1);
    int depth = convert_int(convert_short(y)/convert_short(outputHeight));
    int inyStart = y + depth * heigt_diff;
    int2 coord_out = (int2)(x, y);
    int inxStart = x;
    int2 coord_in = (int2)(inxStart, inyStart);
    int2 coord_wei = (int2)(0, depth);
    float4 sum = 0;
    uint4 dst = {0}, tmp0 = {0}, tmp1 = {0};
    float biasData;
    float4 pixel = {0.0}, weightValue = {0.0}, pixel2 = {0.0};
    biasData = convert_float(read_imagei(bias, (int2)(depth, 0)));
    sum = biasData;
    U8_3x3_X2_NOPAD_2D_PROCESS()
    coord_in.y++;
    coord_wei.x += 3;
    U8_3x3_X2_NOPAD_2D_PROCESS()
    coord_in.y++;
    coord_wei.x += 3;
    U8_3x3_X2_NOPAD_2D_PROCESS()
    dst = convert_uint4(sum * scaleOut + zpOut);
    write_imageui(output, coord_out, dst);
}


__kernel void gpuDepthwiseConv_Quant8(
    image2d_array_t input,
    image2d_t weight,
    image2d_t bias,
    int channel_multiplier,
    int kernelX,
    int kernelY,
    int strideX,
    int strideY,
    int padX,
    int padY,
    float scaleOut,
    float zpIn,
    float zpWeight,
    float zpOut,
    int    zpIn_int,
    image2d_array_t output)
{
    int x = get_global_id(0);
    int y = get_global_id(1);
    int z = get_global_id(2);
    int inputWeight = get_image_width(input);
    int inputHeight = get_image_height(input);
    int inputDepth = get_image_array_size(input);
    int4 coord_out = (int4)(x, y, z, 0);
    int inz = convert_int(convert_short(z)/convert_short(channel_multiplier));
    int inyStart = y * strideY - padY;
    int inyEnd = inyStart + kernelY;
    int inxStart = x * strideX - padX;
    int inxEnd = inxStart + kernelX;
    int4 coord_in = (int4)(inxStart, inyStart, inz, 0);
    int2 coord_wei = (int2)(0, z);
    float sum = 0;
    int   kernelXLeft = 0;
    uint4 dst = {0}, tmp0 = {0}, tmp1 = {0};
    int4 biasData;
    float pixel = 0.0, weightValue = 0.0;

    inyEnd = min(inyEnd, inputHeight);
    inxEnd = min(inxEnd, inputWeight);
    kernelXLeft = kernelX - (inxEnd - inxStart);
    biasData = convert_int(read_imagei(bias, (int2)(z, 0)));
    sum = biasData.x;

    if (inz < inputDepth)
    {
        for (coord_in.y = inyStart; coord_in.y < inyEnd; coord_in.y++)
        {
            for (coord_in.x = inxStart; coord_in.x < inxEnd; coord_in.x++)
            {
                tmp0 = read_imageui(input, coord_in);
                tmp1 = read_imageui(weight, coord_wei);
                coord_wei.x++;

                pixel = convert_float(tmp0.x) -zpIn;
                weightValue = convert_float(tmp1.x)-zpWeight;
                sum += (pixel * weightValue);
            }
            coord_wei.x += kernelXLeft;
        }
    }

    dst.x = floor(sum * scaleOut + zpOut);
    write_imageui(output, coord_out, dst);
}

__kernel void gpuDepthwiseConvNoBias_3x3_FP32(
    image2d_array_t input,
    image2d_t weight,
    int channel_multiplier,
    int kernelX,
    int kernelY,
    int strideX,
    int strideY,
    int padX,
    int padY,
    image2d_array_t output)
{
    int x = get_global_id(0);
    int y = get_global_id(1);
    int z = get_global_id(2);
    int inputWidth = get_image_width(input);
    int inputHeight = get_image_height(input);
    int inputDepth = get_image_array_size(input);
    int4 coord_out = (int4)(x, y, z, 0);
    int inz = convert_int(convert_short(z)/convert_short(channel_multiplier));
    int inyStart = y * strideY - padY;
    int inxStart = x * strideX - padX;
    int inxEndLeft = inxStart + kernelX - inputWidth;
    int4 coord_in = (int4)(inxStart, inyStart, inz, 0);
    int2 coord_wei;
    float sum = 0;
    float4 dst = {0.0};
    float4 pixel = {0.0};
    float4 weightValue = {0.0};

    coord_in.x = coord_in.x < 0 ? 0 : coord_in.x;
    coord_wei = (int2)(0, z);
    F32_3x3_PROCESS()
    coord_in.y++;
    coord_wei.x += kernelX;
    F32_3x3_PROCESS()
    coord_in.y++;
    coord_wei.x += kernelX;
    F32_3x3_PROCESS()

    dst.x = sum;
    write_imagef(output, coord_out, dst);
}



__kernel void gpuDepthwiseConvNoBias_FP32(
    image2d_array_t input,
    image2d_t weight,
    int channel_multiplier,
    int kernelX,
    int kernelY,
    int strideX,
    int strideY,
    int padX,
    int padY,
    image2d_array_t output)
{
    int x = get_global_id(0);
    int y = get_global_id(1);
    int z = get_global_id(2);
    int inputWeight = get_image_width(input);
    int inputHeight = get_image_height(input);
    int inputDepth = get_image_array_size(input);
    int4 coord_out = (int4)(x, y, z, 0);
    int inz = convert_int(convert_short(z)/convert_short(channel_multiplier));
    int inyStart = y * strideY - padY;
    int inyEnd = inyStart + kernelY;
    int inxStart = x * strideX - padX;
    int inxEnd = inxStart + kernelX;
    int4 coord_in = (int4)(inxStart, inyStart, inz, 0);
    int2 coord_wei = (int2)(0, z);
    float sum = 0;
    int   kernelXLeft = 0;
    float4 dst = {0.0};
    float4 pixel = {0.0};
    float4 weightValue = {0.0};

    inyEnd = min(inyEnd, inputHeight);
    inxEnd = min(inxEnd, inputWeight);
    kernelXLeft = kernelX - (inxEnd - inxStart);
    if (inz < inputDepth)
    {
        for (coord_in.y = inyStart; coord_in.y < inyEnd; coord_in.y++)
        {
            for (coord_in.x = inxStart; coord_in.x < inxEnd; coord_in.x++)
            {
                pixel = read_imagef(input, coord_in);
                weightValue = read_imagef(weight, coord_wei);

                coord_wei.x++;

                sum += (pixel.x * weightValue.x);
            }
            coord_wei.x += kernelXLeft;
        }
    }

    dst.x = sum;
    write_imagef(output, coord_out, dst);
}

__kernel void gpuDepthwiseConvNoBias_Quant8(
    image2d_array_t input,
    image2d_t weight,
    int channel_multiplier,
    int kernelX,
    int kernelY,
    int strideX,
    int strideY,
    int padX,
    int padY,
    float scaleIn,
    float scaleWeight,
    float scaleOut,
    int zpIn,
    int zpWeight,
    int zpOut,
    image2d_array_t output)
{
    int x = get_global_id(0);
    int y = get_global_id(1);
    int z = get_global_id(2);
    int inputWeight = get_image_width(input);
    int inputHeight = get_image_height(input);
    int inputDepth = get_image_array_size(input);
    int4 coord_out = (int4)(x, y, z, 0);
    int inz = convert_int(convert_short(z)/convert_short(channel_multiplier));
    int inyStart = y * strideY - padY;
    int inyEnd = inyStart + kernelY;
    int inxStart = x * strideX - padX;
    int inxEnd = inxStart + kernelX;
    int4 coord_in = (int4)(inxStart, inyStart, inz, 0);
    int2 coord_wei = (int2)(0, z);
    float sum = 0;
    int   kernelXLeft = 0;
    uint4 dst = {0}, tmp = {0};
    float pixel = 0.0, weightValue = 0.0;

    inyEnd = min(inyEnd, inputHeight);
    inxEnd = min(inxEnd, inputWeight);
    kernelXLeft = kernelX - (inxEnd - inxStart);
    if (inz < inputDepth)
    {
        for (coord_in.y = inyStart; coord_in.y < inyEnd; coord_in.y++)
        {
            for (coord_in.x = inxStart; coord_in.x < inxEnd; coord_in.x++)
            {
                tmp = read_imageui(input, coord_in);
                pixel = (convert_int(tmp.x-zpIn));
                tmp = read_imageui(weight, coord_wei);
                weightValue = (convert_int(tmp.x-zpWeight));
                sum += (pixel * weightValue);
                coord_wei.x++;
            }
            coord_wei.x += kernelXLeft;
        }
    }

    dst.x = floor(sum * scaleOut * scaleIn * scaleWeight + zpOut + 0.5);
    write_imageui(output, coord_out, dst);
}
